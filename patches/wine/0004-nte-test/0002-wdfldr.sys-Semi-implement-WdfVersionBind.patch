From 94f6d503218eee491f32d76e817368610d3debff Mon Sep 17 00:00:00 2001
From: NelloKudo <marshnelloosu@gmail.com>
Date: Sun, 15 Feb 2026 00:15:26 +0100
Subject: [PATCH 2/6] wdfldr.sys: Semi-implement WdfVersionBind.

---
 dlls/wdfldr.sys/wdfldr_main.c | 83 ++++++++++++++++++++++++++++++++++-
 1 file changed, 81 insertions(+), 2 deletions(-)

diff --git a/dlls/wdfldr.sys/wdfldr_main.c b/dlls/wdfldr.sys/wdfldr_main.c
index 419c50b1b44..dd370237ed6 100644
--- a/dlls/wdfldr.sys/wdfldr_main.c
+++ b/dlls/wdfldr.sys/wdfldr_main.c
@@ -77,11 +77,90 @@ static inline LPCSTR debugstr_us( const UNICODE_STRING *us )
     return debugstr_wn( us->Buffer, us->Length / sizeof(WCHAR) );
 }
 
+static WDFLDR_CLIENT_INFO *find_client_info(DRIVER_OBJECT *driver)
+{
+    WDFLDR_CLIENT_INFO *info;
+
+    LIST_FOR_EACH_ENTRY(info, &client_list, WDFLDR_CLIENT_INFO, entry)
+    {
+        if (info->driver == driver)
+            return info;
+    }
+    return NULL;
+}
+
 NTSTATUS WINAPI WdfVersionBind(DRIVER_OBJECT *driver, UNICODE_STRING *reg_path, 
                                 WDF_BIND_INFO *bind_info, PWDF_COMPONENT_GLOBALS *component_globals)
 {
-    FIXME("%p %s %p %p stub!\n", driver, debugstr_us(reg_path), bind_info, component_globals);
-    return STATUS_SUCCESS;
+    WDFLDR_CLIENT_INFO *client_info;
+    NTSTATUS status = STATUS_SUCCESS;
+
+    TRACE("%p %s version %u.%u.%u, %u functions\n", driver, debugstr_us(reg_path),
+            bind_info->Version.Major, bind_info->Version.Minor, 
+            bind_info->Version.Build, bind_info->FuncCount);
+
+    if (!driver || !reg_path || !bind_info || !component_globals)
+        return STATUS_INVALID_PARAMETER;
+
+    if (bind_info->Size < sizeof(WDF_BIND_INFO))
+        return STATUS_INVALID_PARAMETER;
+
+    EnterCriticalSection(&client_cs);
+
+    /* check if driver is already bound */
+    if (find_client_info(driver))
+    {
+        status = STATUS_OBJECT_NAME_COLLISION;
+        goto done;
+    }
+
+    if (!(client_info = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*client_info))))
+    {
+        status = STATUS_NO_MEMORY;
+        goto done;
+    }
+
+    client_info->registry_path.Length = reg_path->Length;
+    client_info->registry_path.MaximumLength = reg_path->Length + sizeof(WCHAR);
+    if (!(client_info->registry_path.Buffer = HeapAlloc(GetProcessHeap(), 0, 
+                                                         client_info->registry_path.MaximumLength)))
+    {
+        HeapFree(GetProcessHeap(), 0, client_info);
+        status = STATUS_NO_MEMORY;
+        goto done;
+    }
+    memcpy(client_info->registry_path.Buffer, reg_path->Buffer, reg_path->Length);
+    client_info->registry_path.Buffer[reg_path->Length / sizeof(WCHAR)] = 0;
+
+    client_info->driver = driver;
+
+    if (bind_info->FuncCount > 0)
+    {
+        if (!(client_info->func_table = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 
+                                                   bind_info->FuncCount * sizeof(void*))))
+        {
+            HeapFree(GetProcessHeap(), 0, client_info->registry_path.Buffer);
+            HeapFree(GetProcessHeap(), 0, client_info);
+            status = STATUS_NO_MEMORY;
+            goto done;
+        }
+        
+        /* fixme: actually populate the function table (?) */
+    }
+
+    client_info->globals.Size = sizeof(WDF_COMPONENT_GLOBALS);
+    client_info->globals.DriverObject = driver;
+    client_info->globals.RegistryPath = &client_info->registry_path;
+    client_info->globals.FuncTable = client_info->func_table;
+
+    *component_globals = &client_info->globals;
+    
+    list_add_tail(&client_list, &client_info->entry);
+    TRACE("driver %p bound successfully \n", driver);
+
+done:
+    LeaveCriticalSection(&client_cs);
+    return status;
 }
 
 NTSTATUS WINAPI WdfVersionUnbind(UNICODE_STRING *reg_path, WDF_BIND_INFO *bind_info, 
-- 
2.53.0

