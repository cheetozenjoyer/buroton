From 66d15b2da0096a62a56f6b22885bc262dadf4311 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sun, 25 Jan 2026 16:11:18 -0600
Subject: [PATCH 04/12] ntdll: Implement NtDelayExecution relative wait using
 QPC.

Some applications are very timing sensitive.
---
 dlls/ntdll/unix/sync.c | 25 ++++++++++++++++++++-----
 1 file changed, 20 insertions(+), 5 deletions(-)

diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index f5fd233bdf7..7b12ede2ee9 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -2877,16 +2877,31 @@ alert_waited:
     {
         for (;;) select( 0, NULL, NULL, NULL, NULL );
     }
-    else
+    else if (timeout->QuadPart < 0)
     {
+        timeout_t when = -timeout->QuadPart, diff;
         LARGE_INTEGER now;
-        timeout_t when, diff;
 
-        if ((when = timeout->QuadPart) < 0)
+        NtQueryPerformanceCounter( &now, NULL );
+        when += now.QuadPart;
+
+        NtYieldExecution();
+
+        for (;;)
         {
-            NtQuerySystemTime( &now );
-            when = now.QuadPart - when;
+            struct timeval tv;
+            NtQueryPerformanceCounter( &now, NULL );
+            diff = (when - now.QuadPart + 9) / 10;
+            if (diff <= 0) break;
+            tv.tv_sec = diff / 1000000;
+            tv.tv_usec = diff % 1000000;
+            if (select( 0, NULL, NULL, NULL, &tv ) != -1) break;
         }
+    }
+    else
+    {
+        timeout_t when = timeout->QuadPart, diff;
+        LARGE_INTEGER now;
 
         /* Note that we yield after establishing the desired timeout, but
            we only care about the result of the yield for zero timeouts */
-- 
2.53.0

