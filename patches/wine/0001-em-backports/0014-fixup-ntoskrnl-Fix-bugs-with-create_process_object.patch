From 15dbf8108bfa5b0f1a7c9ac664c7e0229621bfdc Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Wed, 23 Jul 2025 02:34:36 -0400
Subject: [PATCH 14/18] fixup! ntoskrnl: Fix bugs with create_process_object.

---
 dlls/ntoskrnl.exe/ntoskrnl.c | 48 +++++++++++++++++++-----------------
 1 file changed, 26 insertions(+), 22 deletions(-)

diff --git a/dlls/ntoskrnl.exe/ntoskrnl.c b/dlls/ntoskrnl.exe/ntoskrnl.c
index 8e8bd728b09..3ab73b5edba 100644
--- a/dlls/ntoskrnl.exe/ntoskrnl.c
+++ b/dlls/ntoskrnl.exe/ntoskrnl.c
@@ -2464,11 +2464,12 @@ NTSTATUS WINAPI FsRtlRegisterUncProvider(PHANDLE MupHandle, PUNICODE_STRING Redi
 
 static void *create_process_object( HANDLE handle )
 {
+    char *p;
     ULONG len;
     HANDLE token;
     PEPROCESS process;
-    ANSI_STRING imageNameA;
-    UNICODE_STRING imageNameW, fullImageName;
+    ANSI_STRING fullImageNameA;
+    UNICODE_STRING fullImageNameW;
 
     if (!(process = alloc_kernel_object( PsProcessType, handle, sizeof(*process), 0 ))) return NULL;
 
@@ -2478,32 +2479,35 @@ static void *create_process_object( HANDLE handle )
     NtQueryInformationProcess( handle, ProcessSessionInformation, &process->session_id, sizeof(process->session_id), NULL );
     NtQueryInformationProcess( handle, ProcessTimes, &process->times, sizeof(process->times), NULL );
 
-    /* get short image name */
-    RtlInitUnicodeString(&imageNameW, NULL);
-    LdrGetDllFullName(handle, &imageNameW);
-    imageNameW.MaximumLength = imageNameW.Length + sizeof(WCHAR);
-    imageNameW.Buffer = ExAllocatePool(PagedPool, imageNameW.MaximumLength);
-    LdrGetDllFullName(handle, &imageNameW);
-    RtlUnicodeStringToAnsiString(&imageNameA, &imageNameW, TRUE);
-    memcpy(process->imageName, imageNameA.Buffer, min(sizeof(process->imageName), imageNameA.Length));
-    RtlFreeAnsiString(&imageNameA);
-    ExFreePool(imageNameW.Buffer);
-
     /* get full image name */
-    RtlInitUnicodeString(&fullImageName, NULL);
-    NtQueryInformationProcess( handle, ProcessImageFileNameWin32, &fullImageName, sizeof(fullImageName), &len );
-    fullImageName.MaximumLength = len;
-    fullImageName.Buffer = ExAllocatePool(PagedPool, len);
-    NtQueryInformationProcess( handle, ProcessImageFileNameWin32, &fullImageName,
-                               sizeof(fullImageName) + fullImageName.MaximumLength, NULL );
-    process->fullImageName = fullImageName;
+    RtlInitUnicodeString(&fullImageNameW, NULL);
+    NtQueryInformationProcess( handle, ProcessImageFileNameWin32, &fullImageNameW, sizeof(fullImageNameW), &len );
+    fullImageNameW.MaximumLength = len;
+    fullImageNameW.Buffer = ExAllocatePool(PagedPool, len);
+    if (!fullImageNameW.Buffer) return NULL;
+    NtQueryInformationProcess( handle, ProcessImageFileNameWin32, &fullImageNameW,
+                               sizeof(fullImageNameW) + fullImageNameW.MaximumLength, NULL );
+    process->fullImageName = fullImageNameW;
+    RtlUnicodeStringToAnsiString(&fullImageNameA, &fullImageNameW, TRUE);
+    if (!fullImageNameA.Buffer) return NULL;
+    /* generate short name */
+    for (p = fullImageNameA.Buffer + fullImageNameA.Length - 1; p >= fullImageNameA.Buffer; p--)
+    {
+        if (*p == '\\')
+        {
+            ++p;
+            break;
+        }
+    }
+    memcpy(process->imageName, p, min(fullImageNameA.Buffer + fullImageNameA.Length - p, sizeof(process->imageName)));
+    RtlFreeAnsiString(&fullImageNameA);
+
+    IsWow64Process( handle, &process->wow64 );
 
     NtOpenProcessToken( handle, TOKEN_ALL_ACCESS, &token );
     ObReferenceObjectByHandle( token, 0, SeTokenObjectType, KernelMode, &process->token, NULL );
     NtClose(token);
 
-    IsWow64Process( handle, &process->wow64 );
-
     return process;
 }
 
-- 
2.53.0

