From ad416d583bc127e144ce00158040c7c989f26062 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Wed, 23 Jul 2025 12:39:47 -0400
Subject: [PATCH 15/18] fixup! ntoskrnl: SeLocateProcessImageName.

---
 dlls/ntoskrnl.exe/ntoskrnl.c         | 72 +++++++++++++++++++++-------
 dlls/ntoskrnl.exe/ntoskrnl.exe.spec  |  2 +-
 dlls/ntoskrnl.exe/ntoskrnl_private.h |  9 +++-
 3 files changed, 62 insertions(+), 21 deletions(-)

diff --git a/dlls/ntoskrnl.exe/ntoskrnl.c b/dlls/ntoskrnl.exe/ntoskrnl.c
index 3ab73b5edba..712a36ab21f 100644
--- a/dlls/ntoskrnl.exe/ntoskrnl.c
+++ b/dlls/ntoskrnl.exe/ntoskrnl.c
@@ -2469,7 +2469,7 @@ static void *create_process_object( HANDLE handle )
     HANDLE token;
     PEPROCESS process;
     ANSI_STRING fullImageNameA;
-    UNICODE_STRING fullImageNameW;
+    UNICODE_STRING *fullImageNameW = NULL;
 
     if (!(process = alloc_kernel_object( PsProcessType, handle, sizeof(*process), 0 ))) return NULL;
 
@@ -2480,15 +2480,12 @@ static void *create_process_object( HANDLE handle )
     NtQueryInformationProcess( handle, ProcessTimes, &process->times, sizeof(process->times), NULL );
 
     /* get full image name */
-    RtlInitUnicodeString(&fullImageNameW, NULL);
-    NtQueryInformationProcess( handle, ProcessImageFileNameWin32, &fullImageNameW, sizeof(fullImageNameW), &len );
-    fullImageNameW.MaximumLength = len;
-    fullImageNameW.Buffer = ExAllocatePool(PagedPool, len);
-    if (!fullImageNameW.Buffer) return NULL;
-    NtQueryInformationProcess( handle, ProcessImageFileNameWin32, &fullImageNameW,
-                               sizeof(fullImageNameW) + fullImageNameW.MaximumLength, NULL );
-    process->fullImageName = fullImageNameW;
-    RtlUnicodeStringToAnsiString(&fullImageNameA, &fullImageNameW, TRUE);
+    NtQueryInformationProcess( handle, ProcessImageFileNameWin32, fullImageNameW, 0, &len );
+    fullImageNameW = malloc(len + sizeof(WCHAR));
+    if (!fullImageNameW) return NULL;
+    fullImageNameW->MaximumLength = len + sizeof(WCHAR);
+    NtQueryInformationProcess( handle, ProcessImageFileNameWin32, fullImageNameW, len, &len );
+    RtlUnicodeStringToAnsiString(&fullImageNameA, fullImageNameW, TRUE);
     if (!fullImageNameA.Buffer) return NULL;
     /* generate short name */
     for (p = fullImageNameA.Buffer + fullImageNameA.Length - 1; p >= fullImageNameA.Buffer; p--)
@@ -2501,6 +2498,7 @@ static void *create_process_object( HANDLE handle )
     }
     memcpy(process->imageName, p, min(fullImageNameA.Buffer + fullImageNameA.Length - p, sizeof(process->imageName)));
     RtlFreeAnsiString(&fullImageNameA);
+    free(fullImageNameW);
 
     IsWow64Process( handle, &process->wow64 );
 
@@ -2514,8 +2512,11 @@ static void *create_process_object( HANDLE handle )
 void release_process_object(void *obj)
 {
     PEPROCESS process = obj;
-    ExFreePool(process->fullImageName.Buffer);
-    ObDereferenceObject(process->token);
+
+    if (process->token)
+        ObDereferenceObject(process->token);
+
+    process->token = NULL;
 
     SERVER_START_REQ( release_kernel_object )
     {
@@ -2738,11 +2739,10 @@ HANDLE WINAPI PsGetThreadProcessId( PETHREAD thread )
  */
 NTSTATUS WINAPI PsGetContextThread(PETHREAD thread, CONTEXT *context)
 {
-    HANDLE handle;
     NTSTATUS status;
-    ULONG_PTR id = (ULONG_PTR) PsGetThreadId(thread);
+    HANDLE handle, id = PsGetThreadId(thread);
 
-    if (!(handle = OpenThread(THREAD_ALL_ACCESS, FALSE, id)))
+    if (!(handle = OpenThread(THREAD_ALL_ACCESS, FALSE, HandleToUlong(id))))
         return STATUS_NOT_FOUND;
 
     status = NtGetContextThread(handle, context);
@@ -3091,6 +3091,18 @@ PHYSICAL_ADDRESS WINAPI MmGetPhysicalAddress(void *virtual_address)
     return ret;
 }
 
+PHYSICAL_MEMORY_RANGE *WINAPI MmGetPhysicalMemoryRanges(void)
+{
+    static PHYSICAL_MEMORY_RANGE range = {
+        .BaseAddress.QuadPart = 0xdead,
+        .NumberOfBytes.QuadPart = 0x10000000
+    };
+
+    FIXME("stub!\n");
+
+    return &range;
+}
+
 /***********************************************************************
  *           MmGetVirtualForPhysical   (NTOSKRNL.EXE.@)
  */
@@ -4450,18 +4462,42 @@ BOOLEAN WINAPI SePrivilegeCheck(PRIVILEGE_SET *privileges, SECURITY_SUBJECT_CONT
  */
 NTSTATUS WINAPI SeLocateProcessImageName(PEPROCESS process, UNICODE_STRING **image_name)
 {
+    ULONG len;
+    NTSTATUS status;
+    HANDLE handle, id = PsGetProcessId(process);
+
     TRACE("%p %p\n", process, image_name);
 
     if (!image_name) return STATUS_INVALID_PARAMETER;
 
-    *image_name = ExAllocatePool(PagedPool, sizeof(UNICODE_STRING));
+    if (!(handle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, HandleToUlong(id))))
+        return STATUS_NOT_FOUND;
 
-    if (!*image_name) return STATUS_NO_MEMORY;
+    NtQueryInformationProcess(handle, ProcessImageFileNameWin32, *image_name, 0, &len);
 
-    **image_name = process->fullImageName;
+    len += sizeof(WCHAR);
+
+    *image_name = ExAllocatePool(PagedPool, len);
+
+    if (!*image_name)
+    {
+        NtClose(handle);
+        return STATUS_NO_MEMORY;
+    }
+
+    (*image_name)->MaximumLength = len;
+
+    if ((status = NtQueryInformationProcess(handle, ProcessImageFileNameWin32,
+                                            *image_name, len - sizeof(WCHAR), &len)))
+    {
+        NtClose(handle);
+        return status;
+    }
 
     TRACE("ret: %s\n", debugstr_us(*image_name));
 
+    NtClose(handle);
+
     return STATUS_SUCCESS;
 }
 
diff --git a/dlls/ntoskrnl.exe/ntoskrnl.exe.spec b/dlls/ntoskrnl.exe/ntoskrnl.exe.spec
index 9df5642878d..f7e25ddf868 100644
--- a/dlls/ntoskrnl.exe/ntoskrnl.exe.spec
+++ b/dlls/ntoskrnl.exe/ntoskrnl.exe.spec
@@ -725,7 +725,7 @@
 @ stdcall MmFreeNonCachedMemory(ptr long)
 @ stub MmFreePagesFromMdl
 @ stdcall MmGetPhysicalAddress(ptr)
-@ stub MmGetPhysicalMemoryRanges
+@ stdcall MmGetPhysicalMemoryRanges()
 @ stdcall MmGetSystemRoutineAddress(ptr)
 @ stdcall MmGetVirtualForPhysical(int64)
 @ stub MmGrowKernelStack
diff --git a/dlls/ntoskrnl.exe/ntoskrnl_private.h b/dlls/ntoskrnl.exe/ntoskrnl_private.h
index 10aebe722de..14d5a3a4e29 100644
--- a/dlls/ntoskrnl.exe/ntoskrnl_private.h
+++ b/dlls/ntoskrnl.exe/ntoskrnl_private.h
@@ -56,9 +56,8 @@ struct _EPROCESS
     PROCESS_BASIC_INFORMATION info;
     KERNEL_USER_TIMES times;
     BOOL wow64;
-    ULONG session_id;
+    DWORD session_id;
     PACCESS_TOKEN token;
-    UNICODE_STRING fullImageName;
     char imageName[15];
 };
 
@@ -76,6 +75,12 @@ struct _ETHREAD
     struct _KTHREAD kthread;
 };
 
+typedef struct _PHYSICAL_MEMORY_RANGE {
+    PHYSICAL_ADDRESS BaseAddress;
+    LARGE_INTEGER NumberOfBytes;
+} PHYSICAL_MEMORY_RANGE, *PPHYSICAL_MEMORY_RANGE;
+
+
 void *alloc_kernel_object( POBJECT_TYPE type, HANDLE handle, SIZE_T size, LONG ref );
 NTSTATUS kernel_object_from_handle( HANDLE handle, POBJECT_TYPE type, void **ret );
 
-- 
2.53.0

